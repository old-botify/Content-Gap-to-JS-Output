This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-04T21:16:45.047Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
branded_lists/
  jewelry-branded-terms.md
  signet_branded_list.csv
templates/
  upload.html
.gitattributes
.gitignore
app.py
README.md
requirements.txt

================================================================
Repository Files
================================================================

================
File: branded_lists/jewelry-branded-terms.md
================
# Branded Terms by Jewelry Retailer (Including Common Misspellings)

## Common Misspellings Patterns
- Double/single letter variations (e.g., brilliant/briliant)
- Phonetic misspellings (e.g., jewelry/jewelery)
- Space/hyphen variations (e.g., bluenile/blue-nile)
- Sound-alike endings (e.g., tiffany's/tiffanys)
- Missing letters (e.g., brilliant/brillant)
- Added letters (e.g., pandora/pandorah)

## Kay Jewelers (kay.com)
Kay, Kay Jewelers, The Kay Collection, Leo Diamond, Neil Lane, Neil Lane Bridal, Neil Lane Designs, Open Hearts by Jane Seymour, Now & Forever, Ever Us, Le Vian, Hearts Desire, Tolkowsky, Adrianna Papell, Love's Destiny, Charmed Memories, Kay Jewelers Outlet, The Store For Romance, Every Kiss Begins with Kay

## Kay Outlet (kayoutlet.com)
Kay Outlet, Kay Jewelers Outlet, Kay Outlet Collection, Kay Clearance, Kay Outlet Exclusive

## Jared (jared.com)
Jared, Jared The Galleria Of Jewelry, Jared Vault, Chosen by Jared, Jared Atelier, First Light Diamond, Royal Asscher, Earthly Treasures Smithsonian, The Leo Diamond, Le Vian, Pnina Tornai, Vera Wang LOVE, Hearts Desire, JB Star, PANDORA at Jared, The Art of Brilliance

## Zales (zales.com)
Zales, The Diamond Store, Zales Outlet, Vera Wang LOVE, Arctic Brilliance, The Celebration Diamond, Endless Brilliance, Love's Destiny Collection, The Promise Collection, Unstoppable Love, Brilliant Buy Collection, Zales Designer Outlets, Everything You Are

## Blue Nile (bluenile.com)
Blue Nile, Blue Nile Studio, Astor by Blue Nile, Blue Nile Signature, Build Your Own Ring, Blue Nile Diamond Search, The Blue Nile Collection, Premier Collection, Reserve Collection, Blue Nile Studio Collection

## Brilliant Earth (brilliantearth.com)
Brilliant Earth, Beyond Conflict Free Diamonds, Origin Collection, Stellar Collection, Waverly Collection, Nova Collection, Luxe Collection, The Gallery Collection, BE Signature Collection, Versailles Collection

## James Allen (jamesallen.com)
James Allen, True Hearts, James Allen Collection, JA Reserve Collection, Designer Collection, Art Masters Collection, True Hearts Collection, Exclusive Collection, True-Hearts Diamond Collection

## Tiffany & Co. (tiffany.com)
Tiffany, Tiffany & Co., T Collection, Tiffany True, Tiffany Setting, Tiffany Victoria, Tiffany Soleste, Tiffany Legacy, Tiffany Harmony, Tiffany Embrace, Tiffany Keys, Return to Tiffany, Please Return to Tiffany, Atlas Collection, Tiffany T, Tiffany HardWear, Tiffany Paper Flowers, Tiffany 1837, Tiffany Blue Box, Tiffany Blue

## Pandora (pandora.net)
PANDORA, Pandora Moments, Pandora Signature, Pandora ME, Pandora Timeless, Pandora Garden, Pandora Brilliance, Pandora Reflexions, Pandora O Pendant, Pandora Club Charm, Pandora Rose, Pandora Shine, Pandora Sterling Silver, Pandora Charms, Pandora Bracelets

## Helzberg (helzberg.com)
Helzberg, Helzberg Diamonds, Helzberg Diamond Masterpiece, Radiant Star, Masterpiece Collection, Eternally Yours, I Am Loved, Diamond Symphony, ForevermarkⓇ by Helzberg, Royal Asscher, Love Lives Forever, Diamond Masterpiece

## Shane Co. (shaneco.com)
Shane Co., Shane Company, Direct Diamond Importers, Your Friend in the Diamond Business, Natural Sapphire Company, Shane Classic, Tom Shane Collection, Eternal Collection, Entwined Collection, Forever Collection, Now That's a Brilliant Diamond

================
File: branded_lists/signet_branded_list.csv
================
kay, k.a.y, kayjewelers, kay jewlers, kay jewelery, kay jewelars, kay jewelry, kay jewlery, kay outlet, kayoutlet, kay's, kays, the kay collection, kay collections, leo diamond, leo diamonds, neil lane, niel lane, neal lane, neil laine, open hearts, ever us, everus, le vian, levian, le-vian, hearts desire, hearts' desire, tolkowsky, tolkowsy, tolkovsky, adrianna papell, adriana papell, adrianna papel, charmed memories, charm memories, kay outlet, evry kiss begins with kay, every kiss begins with k, jared, jareds, jared's, jerad, jarred, jarrad, jared galleria, jared galeria, jared gallery, the galleria of jewelry, galleria of jewelery, jared vault, jerad vault, chosen by jared, chosen by jareds, jared atelier, first light diamond, royal asscher, royal ascher, royal asher, earthly treasures smithsonian, le vian, levian, le-vian, pnina tornai, pnina tornay, pninna tornai, vera wang love, vera wang, hearts desire, heart's desire, jb star, pandora at jared, art of brilliance, zales, zale's, zails, zayles, the diamond store, zales outlet, zails outlet, vera wang love, arctic brilliance, artic brilliance, arctic briliance, celebration diamond, endless brilliance, endless briliance, loves destiny, love's destiny, promise collection, unstopable love, unstoppable love, brilliant buy, designer outlets, everything you are, blue nile, bluenile, blu nile, blue-nile, blue nile studio, astor by blue nile, blue nile signature, blue nyle, blunile, build your own ring, diamond search, premier collection, reserve collection, studio collection, brilliant earth, brillant earth, briliant earth, brillient earth, brilliant-earth, brilliantearth, beyond conflict free, beyond conflict-free, origin collection, stellar collection, waverly collection, waverly diamonds, nova collection, luxe collection, gallery collection, be signature, versailles collection, versails collection, james allen, jamesallen, james-allen, james allan, james alen, true hearts, truhearts, true-hearts, ja reserve, designer collection, art masters, true hearts collection, exclusive collection, tiffany, tiffanys, tiffany's, tiffanies, tiffani, tifany, tiffany & co, tiffany and co, tiffany & company, t collection, tiffany true, the tiffany setting, tiffany victoria, tiffany soleste, tiffany legacy, tiffany harmony, tiffany embrace, tiffany keys, return to tiffany, please return to tiffany, atlas collection, tiffany t, tiffany hardware, tiffany hardwear, tiffany paper flowers, tiffany 1837, blue box, tiffany blue, pandora, pandorah, pandora's, pandoras, padora, pandorra, pandora moments, pandora signature, pandora me, pandora timeless, pandora garden, pandora brilliance, pandora reflexions, pandora reflections, pandora reflextions, pandora o pendant, pandora club charm, pandora rose, pandora shine, pandora sterling, pandora charms, pandorah charms, pandora bracelet, pandora bracelets, helzberg, helzbergs, helzberg's, helzburg, helzburgh, helzberg diamonds, helsburg diamonds, helzberg masterpiece, radiant star, masterpiece collection, eternally yours, i am loved, diamond symphony, forevermark, forevermark by helzberg, royal asscher, royal ascher, love lives forever,shane co, shaneco, shane company, shane & company, shane and company, shane & co, shane and co, direct diamond importers, friend in the diamond business, natural sapphire company, shane classic, tom shane, eternal collection, entwined collection, forever collection, brilliant diamond, your friend in the diamond business, your friend in the jewelry business

================
File: templates/upload.html
================
<!DOCTYPE html>
<html>
<head>
    <title>Keyword Processor</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #1a1a1a;
            color: #b19cd9;
        }
        .container {
            background-color: #2d2d2d;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .form-group {
            margin-bottom: 20px;
        }
        .form-row {
            display: flex;
            gap: 20px;
            margin-bottom: 10px;
        }
        .form-col {
            flex: 1;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #d4bfff;
        }
        input[type="file"],
        input[type="text"],
        input[type="number"] {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #4a4a4a;
            border-radius: 4px;
            background-color: #333333;
            color: #b19cd9;
        }
        input[type="file"] {
            color: #b19cd9;
            cursor: pointer;
        }
        input[type="file"]::-webkit-file-upload-button {
            background-color: #6b4ba3;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }
        input[type="file"]::-webkit-file-upload-button:hover {
            background-color: #8360c3;
        }
        button {
            background-color: #6b4ba3;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        button:hover {
            background-color: #8360c3;
        }
        button:disabled {
            background-color: #4a4a4a;
            cursor: not-allowed;
        }
        .help-text {
            font-size: 0.9em;
            color: #9985c7;
            margin-top: 5px;
        }
        .error-message {
            background-color: #442233;
            color: #ff99cc;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 20px;
            border: 1px solid #663344;
        }
        .success-message {
            background-color: #224433;
            color: #99ffcc;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 20px;
            border: 1px solid #336644;
        }
        h1 {
            color: #d4bfff;
            margin-bottom: 30px;
        }
        .progress-container {
            display: none;
            margin-top: 20px;
            padding: 10px;
            border-radius: 4px;
            background-color: #333333;
        }
        .progress-bar {
            height: 20px;
            background-color: #6b4ba3;
            width: 0%;
            border-radius: 4px;
            transition: width 0.3s ease-in-out;
        }
        .progress-text {
            color: #d4bfff;
            text-align: center;
            margin-top: 5px;
        }
        .button-group {
            margin-top: 20px;
            display: none;
        }
        .filter-section {
            background-color: #333333;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        .filter-section h2 {
            color: #d4bfff;
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 15px;
        }
    </style>
    <script>
        let progressInterval;
        
        function showProgress() {
            document.getElementById('progress-container').style.display = 'block';
            document.getElementById('upload-button').disabled = true;
            checkProgress();
        }
        
        function checkProgress() {
            progressInterval = setInterval(() => {
                fetch('/progress')
                    .then(response => response.json())
                    .then(data => {
                        const progress = data.progress;
                        document.getElementById('progress-bar').style.width = progress + '%';
                        document.getElementById('progress-text').textContent = `Processing: ${progress}%`;
                        
                        if (progress === 100) {
                            clearInterval(progressInterval);
                            document.getElementById('button-group').style.display = 'block';
                            document.getElementById('upload-button').disabled = false;
                        }
                    });
            }, 500);
        }
        
        function cleanFiles() {
            fetch('/clean-files', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        showMessage('All files cleaned successfully', true);
                    } else {
                        showMessage('Error cleaning files: ' + data.error, false);
                    }
                })
                .catch(error => showMessage('Error: ' + error, false));
        }
        
        function showMessage(message, isSuccess) {
            const messageDiv = document.createElement('div');
            messageDiv.className = isSuccess ? 'success-message' : 'error-message';
            messageDiv.textContent = message;
            
            const container = document.querySelector('.container');
            container.insertBefore(messageDiv, container.firstChild);
            
            setTimeout(() => messageDiv.remove(), 5000);
        }
        
        function downloadJS() {
            window.location.href = '/download-js';
        }

        function validateForm() {
            const form = document.getElementById('upload-form');
            const minPosition = form.min_position.value;
            const maxPosition = form.max_position.value;
            const minSearchVolume = form.min_search_volume.value;
            const maxSearchVolume = form.max_search_volume.value;

            if (minPosition && maxPosition && parseInt(minPosition) > parseInt(maxPosition)) {
                showMessage('Minimum position cannot be greater than maximum position', false);
                return false;
            }

            if (minSearchVolume && maxSearchVolume && parseInt(minSearchVolume) > parseInt(maxSearchVolume)) {
                showMessage('Minimum search volume cannot be greater than maximum search volume', false);
                return false;
            }

            return true;
        }
    </script>
</head>
<body>
    <div class="container">
        <h1>Keyword Processor</h1>
        
        {% if error %}
        <div class="error-message">
            {{ error }}
        </div>
        {% endif %}
        
        <form id="upload-form" method="post" enctype="multipart/form-data" onsubmit="return validateForm() && showProgress()">
            <div class="form-group">
                <label for="file">Select File:</label>
                <input type="file" id="file" name="file" accept=".xlsx,.csv" required>
                <div class="help-text">Please upload an Excel file (.xlsx) or CSV file (.csv)</div>
            </div>
            
            <div class="form-group">
                <label for="brand_terms">Brand Terms:</label>
                <input type="text" id="brand_terms" name="brand_terms" 
                       placeholder="Enter brand terms, separated by commas" required>
                <div class="help-text">
                    Example: david's bridal, david, bridal, db
                    <br>
                    These terms will be used to identify branded keywords (case insensitive)
                </div>
            </div>

            <div class="filter-section">
                <h2>Filter Options</h2>
                <div class="form-row">
                    <div class="form-col">
                        <label for="min_position">Minimum Position:</label>
                        <input type="number" id="min_position" name="min_position" min="1"
                               placeholder="e.g., 1">
                    </div>
                    <div class="form-col">
                        <label for="max_position">Maximum Position:</label>
                        <input type="number" id="max_position" name="max_position" min="1"
                               placeholder="e.g., 100">
                    </div>
                </div>
                <div class="form-row">
                    <div class="form-col">
                        <label for="min_search_volume">Minimum Search Volume:</label>
                        <input type="number" id="min_search_volume" name="min_search_volume" min="0"
                               placeholder="e.g., 1000">
                    </div>
                    <div class="form-col">
                        <label for="max_search_volume">Maximum Search Volume:</label>
                        <input type="number" id="max_search_volume" name="max_search_volume" min="0"
                               placeholder="e.g., 1000000">
                    </div>
                </div>
                <div class="help-text">
                    Leave fields empty to include all results. Filters are optional.
                </div>
            </div>
            
            <button type="submit" id="upload-button">Process File</button>
        </form>
        
        <div id="progress-container" class="progress-container">
            <div id="progress-bar" class="progress-bar"></div>
            <div id="progress-text" class="progress-text">Processing: 0%</div>
        </div>
        
        <div id="button-group" class="button-group">
            <button onclick="downloadJS()">Download JS File</button>
            <button onclick="cleanFiles()">Clean All Files</button>
        </div>
    </div>
</body>
</html>

================
File: .gitattributes
================
# Auto detect text files and perform LF normalization
* text=auto

================
File: .gitignore
================
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual Environment
venv/
ENV/
.env

# IDE
.idea/
.vscode/
*.swp
*.swo
.DS_Store

# Project specific
uploads/*
source_files/*
!uploads/.gitkeep
*.xlsx
*.xls
*.js

gap_analysis_results.csv

================
File: app.py
================
from flask import Flask, request, render_template, send_file, jsonify
import pandas as pd
import json
from pathlib import Path
import re
from werkzeug.utils import secure_filename
import os
import time
import glob
import logging
import shutil

# Set up logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

app = Flask(__name__)
app.secret_key = 'your-secret-key-here'

# Configure folders
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
UPLOAD_FOLDER = os.path.join(BASE_DIR, 'uploads')
OUTPUT_FOLDER = os.path.join(BASE_DIR, 'output')

# Create necessary folders
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
os.makedirs(OUTPUT_FOLDER, exist_ok=True)

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['OUTPUT_FOLDER'] = OUTPUT_FOLDER

def clean_directory(directory):
    """Clean all files in a directory"""
    try:
        for filename in os.listdir(directory):
            file_path = os.path.join(directory, filename)
            try:
                if os.path.isfile(file_path):
                    os.remove(file_path)
                elif os.path.isdir(file_path):
                    shutil.rmtree(file_path)
            except Exception as e:
                logger.error(f"Error removing {file_path}: {e}")
    except Exception as e:
        logger.error(f"Error cleaning directory {directory}: {e}")

def save_json_file(data, filename, minified=False):
    """Save JSON data to a file, with error checking"""
    filepath = os.path.join(app.config['OUTPUT_FOLDER'], filename)
    try:
        with open(filepath, 'w', encoding='utf-8') as f:
            if minified:
                json.dump(data, f, separators=(',', ':'))
            else:
                json.dump(data, f, indent=2)
        
        # Verify file was written correctly
        if not os.path.exists(filepath):
            raise Exception(f"File {filepath} was not created")
        
        file_size = os.path.getsize(filepath)
        logger.debug(f"Successfully wrote {filename} ({file_size} bytes)")
        
        # Verify file can be read back
        with open(filepath, 'r', encoding='utf-8') as f:
            _ = json.load(f)
            
        return filepath
    except Exception as e:
        logger.error(f"Error saving {filename}: {e}")
        raise

[... keep all the existing helper functions (allowed_file, is_branded, read_file) ...]

def process_excel(file_path, brand_terms):
    """Process Excel/CSV file and check for branded keywords"""
    global processing_progress
    
    try:
        processing_progress = 5
        df = read_file(file_path)
        processing_progress = 20
        
        logger.debug(f"DataFrame Info:\n{df.info()}")
        logger.debug(f"First few rows:\n{df.head()}")
        
        competitor_columns = [col for col in df.columns if str(col).lower().endswith('.com')]
        logger.debug(f"Found competitor columns: {competitor_columns}")
        
        keyword_data = []
        total_rows = len(df)
        
        for idx, row in df.iterrows():
            try:
                processing_progress = 20 + int((idx / total_rows) * 70)
                
                competitors = []
                for comp in competitor_columns:
                    if pd.notna(row[comp]):
                        try:
                            rank = float(row[comp])
                            competitors.append({
                                "name": comp,
                                "rank": int(rank)
                            })
                        except (ValueError, TypeError) as e:
                            logger.warning(f"Error processing competitor {comp} for row {idx}: {e}")
                            continue
                
                search_volume = 0
                if 'Search Volume' in row:
                    try:
                        if pd.notna(row['Search Volume']):
                            sv_str = str(row['Search Volume']).replace(',', '')
                            search_volume = int(float(sv_str))
                    except (ValueError, TypeError) as e:
                        logger.warning(f"Error processing search volume for row {idx}: {e}")
                
                keyword = str(row.get('Keyword', '')).lower().strip()
                if not keyword:
                    logger.warning(f"Skipping row {idx}: Empty keyword")
                    continue
                
                category = str(row.get('Keyword Group (Experimental)', 'Other'))
                if pd.isna(category) or not category.strip():
                    category = 'Other'
                
                keyword_entry = {
                    "keyword": keyword,
                    "category": category,
                    "searchVolume": search_volume,
                    "isBranded": is_branded(keyword, brand_terms),
                    "competitors": sorted(competitors, key=lambda x: x['rank'])
                }
                
                if idx < 5 or len(competitors) > 0:
                    logger.debug(f"Processed keyword entry: {json.dumps(keyword_entry, indent=2)}")
                
                keyword_data.append(keyword_entry)
                
            except Exception as e:
                logger.error(f"Error processing row {idx + 2}: {str(e)}", exc_info=True)
                continue
        
        processing_progress = 100
        return keyword_data
        
    except Exception as e:
        processing_progress = 0
        logger.error(f"Error processing file: {str(e)}", exc_info=True)
        raise

@app.route('/progress')
def get_progress():
    return jsonify({'progress': processing_progress})

@app.route('/clean-files', methods=['POST'])
def clean_files():
    try:
        clean_directory(app.config['UPLOAD_FOLDER'])
        clean_directory(app.config['OUTPUT_FOLDER'])
        return jsonify({'success': True, 'message': 'All files cleaned successfully'})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/download-js')
def download_js():
    try:
        # Try to find both versions
        js_file = os.path.join(app.config['OUTPUT_FOLDER'], 'keyword_data.js')
        js_file_min = os.path.join(app.config['OUTPUT_FOLDER'], 'keyword_data.min.js')
        
        if os.path.exists(js_file):
            return send_file(js_file, as_attachment=True, download_name='keyword_data.js')
        elif os.path.exists(js_file_min):
            return send_file(js_file_min, as_attachment=True, download_name='keyword_data.js')
        else:
            return jsonify({'success': False, 'error': 'No processed file found'})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/', methods=['GET', 'POST'])
def upload_file():
    global processing_progress
    
    if request.method == 'POST':
        try:
            processing_progress = 0
            
            if 'file' not in request.files:
                return render_template('upload.html', error='No file uploaded')
            
            file = request.files['file']
            brand_terms = request.form.get('brand_terms', '').split(',')
            
            if file.filename == '':
                return render_template('upload.html', error='No file selected')
            
            if not allowed_file(file.filename):
                return render_template('upload.html', error='Only .xlsx and .csv files are allowed')
            
            # Clean output directory before processing
            clean_directory(app.config['OUTPUT_FOLDER'])
            
            filename = secure_filename(file.filename)
            filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
            
            file.save(filepath)
            
            try:
                keyword_data = process_excel(filepath, brand_terms)
                
                # Save both versions with proper JS export
                js_output_readable = "export const keywordData = " + json.dumps(keyword_data, indent=2) + ";"
                js_output_minified = "export const keywordData=" + json.dumps(keyword_data, separators=(',', ':')) + ";"
                
                # Save both versions with error checking
                output_path_readable = os.path.join(app.config['OUTPUT_FOLDER'], 'keyword_data.js')
                output_path_min = os.path.join(app.config['OUTPUT_FOLDER'], 'keyword_data.min.js')
                
                with open(output_path_readable, 'w', encoding='utf-8') as f:
                    f.write(js_output_readable)
                
                with open(output_path_min, 'w', encoding='utf-8') as f:
                    f.write(js_output_minified)
                
                # Verify files were created
                if not (os.path.exists(output_path_readable) and os.path.exists(output_path_min)):
                    raise Exception("Output files were not created properly")
                
                # Log file sizes
                readable_size = os.path.getsize(output_path_readable)
                min_size = os.path.getsize(output_path_min)
                logger.debug(f"Readable file size: {readable_size} bytes")
                logger.debug(f"Minified file size: {min_size} bytes")
                
                # Clean up upload
                if os.path.exists(filepath):
                    os.remove(filepath)
                
                # Return the readable version
                return send_file(output_path_readable, as_attachment=True, download_name='keyword_data.js')
                
            except Exception as e:
                logger.error("Error processing file", exc_info=True)
                if os.path.exists(filepath):
                    os.remove(filepath)
                return render_template('upload.html', error=f'Error processing file: {str(e)}')
            
        except Exception as e:
            logger.error("Error uploading file", exc_info=True)
            return render_template('upload.html', error=f'Error uploading file: {str(e)}')
            
    return render_template('upload.html')

if __name__ == '__main__':
    app.run(debug=True)

================
File: README.md
================
# Keyword Processor

A Flask-based web application that processes Excel files containing keyword data and generates JavaScript output with branded keyword detection.

## Features

- Upload and process Excel files containing keyword data
- Detect branded keywords based on user-defined terms
- Real-time progress tracking
- File management system
- Dark theme UI with purple accents
- Support for large files (up to 100MB)

## Installation

1. Clone the repository:
```bash
git clone <repository-url>
cd keyword-processor
```

2. Create a virtual environment:
```bash
python -m venv venv
```

3. Activate the virtual environment:
- On Windows:
  ```bash
  venv\Scripts\activate
  ```
- On macOS/Linux:
  ```bash
  source venv/bin/activate
  ```

4. Install dependencies:
```bash
pip install -r requirements.txt
```

## Usage

1. Start the Flask application:
```bash
python app.py
```

2. Open your web browser and navigate to:
```
http://localhost:5000
```

3. Upload an Excel file and enter brand terms:
   - Select an .xlsx file containing keyword data
   - Enter brand terms separated by commas
   - Click "Process File" to start processing

4. Features available:
   - Progress tracking during processing
   - Download processed JavaScript file
   - Clean temporary files
   - Redownload previously processed file

## Input File Format

The Excel file should contain the following columns:
- Keyword: The keyword to process
- Search Volume: Monthly search volume
- Competitor columns (ending in .com): Competitor rankings
- Keyword Group (Experimental): Category information

## Output Format

The processed data will be saved as a JavaScript file with the following structure:
```javascript
export const keywordData = [
    {
        "keyword": "example keyword",
        "category": "Category",
        "searchVolume": 1000,
        "isBranded": true,
        "competitors": [
            {
                "name": "competitor1.com",
                "rank": 10
            }
        ]
    }
];
```

## Project Structure

```
keyword-processor/
├── app.py                 # Main Flask application
├── requirements.txt       # Python dependencies
├── README.md             # Project documentation
├── .gitignore            # Git ignore file
├── uploads/              # Temporary file storage
└── templates/
    └── upload.html       # HTML template
```

## Contributing

1. Fork the repository
2. Create a feature branch
3. Commit your changes
4. Push to the branch
5. Create a Pull Request

## License

This project is licensed under the MIT License - see the LICENSE file for details.

================
File: requirements.txt
================
Flask>=2.0.0
pandas>=1.3.0
openpyxl>=3.0.0
Werkzeug>=2.0.0
pathlib>=1.0.0
